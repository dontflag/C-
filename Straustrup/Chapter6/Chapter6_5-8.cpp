#include "stdafx.h"
#include "Chapter6_5-8.h"

using namespace std;


/* НЕ НАДО ДВАЖДЫ ИЗМЕНЯТЬ ОДНУ ПЕРЕМЕННУЮ В ОДНОМ ВЫРАЖЕНИИ: http://alenacpp.blogspot.com/2005/11/sequence-points.html */
void Chapter6_5_8()
{
	//1) undefined
	/*	short test[5];
		test = 'a';		*/
	//2) undefined
	/*	char* ptr;
		ptr = 1;	*/
	//3) undefined
	/*	int test = "a"; */ //а с 'a' выполнится (конвертация char в int)
	//4) undefined
	/*	5 = 7;	*/
	//5) undefined
	/*	char& ref = 'a'; */

	//1) depends on realization
	/*char* ptr;
	sizeof(ptr); //на 64-битных платформах указатель занимает 8 байт, а на 32-битных - 4 байта */
	//можно такое же для каждого типа данных (signed, unsigned к любому ТД, int, char, float(double, long double) - все они могут иметь разные размеры, и ограничения на значения, в зависимости от реализации

	//1) immovable code
	/*	char c = 255; //иногда диапазон значений char лежит между 0..255, иногда - -127..128 */
	//2) immovable code
	/* int Arr1[5] = { 1,5,7,9,11 };
	int Arr2[5] = { 2,4,6,8,10 };
	int i = 0;
	for (short j = 0; j < 5; j++)
	{
		int x = Arr1[i++] + Arr2[i++];
		cout << x << "\n";
	} */ //т.н. код с side effect-ами. Приоритет инкрементации выше, однако, при смене мест слагаемых, результат изменится, и оператор "+" теряет свойство ассоциативности.

	//Так же справедливы предыдущие примеры, касающиеся диапазонов значений, размеров типов данных, указателей. 

	/* ПРЕФИКСНЫЙ ИНКРЕМЕНТ/ДЕКРЕМЕНТ СНАЧАЛА МЕНЯЕТ ПЕРЕМЕННУЮ, А ПОТОМ ИСПОЛЬЗУЕТ ЕЁ В ВЫРАЖЕНИИ, А ПОСТФИКСНЫЙ, СООТВЕТСТВЕННО, НАОБОРОТ*/
	
	//1) execution order
		/*i = i++ + i--; //- неизвестно, в каком порядке будет вычислен какой из аргументов */
	//2) v[i] = i++

	/* Однако ',', логические "И", "ИЛИ", вычисляют свой левый операнд раньше, чем правый, и тернарный оператор a?b:c вычислит "а" раньше*/

	//3) f(v[i],i++)// - неизвестно в каком порядке будут вычислены аргументы
		//f2((v[i],i++)) - а тут известно: левый аргумент первым, т.к. операция следования

	short i = numeric_limits<short>::max();
	cout << "max short: " << i << "\n";
	//cout << "max short div by zero: " << i / 0 << "\n"; - exception
	cout << "max short + 1: " << i + 1 << "\n"; // - 32768, и конвертация в int
	cout << sizeof(i) << " " << sizeof(i + 1) << "\n"; // 2 4
	float j = 2.5539399;
	cout << sizeof(j) << " " << sizeof(j / 5.666969622244) << "\n"; //4 8, float конвертируется в double автоматом

	

}